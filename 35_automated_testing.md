# Manual versus Automated Testing

So far, we have focused mostly on manual testing; that is, we actually develop and run the test cases ourselves.  If you've done any manual testing, though, you'll know that it is time-consuming and often extremely boring for the tester who has to follow a script (it's much more fun to follow a script when acting than when running software).  If only there were some sort of machine which can be used for running repetitive tasks!

If you're testing software, then chances are very good that you have a computer available to help you with the tests, since you probably have a computer available to you to run the software that you're testing.  There are numerous tools to help you test the software more effectively and efficiently.

With automated testing, you write the tests, using some sort of programming or scripting language or tool, which are then executed by the computer.  These tests can check aspects of the program as specific as individual return values from methods all the way up to how an entire graphical interface should look on a screen.

## Benefits and Drawbacks of Manual Testing

### Benefits of Manual Testing

1. _It's simple and straightforward._  There's a reason that this book discussed manual testing first; it's easier to understand the concepts of testing without worrying about the particular syntax or quirks of tools or languages being used.  You're using the same software setup, or at least a very similar setup, as the user.  Most people, even ones who are not very technical, can follow a well-written test plan.  Most non-technical people would have great difficulty understanding a JUnit test, however.
2. _It's cheap._ At least from a na√Øve perspective, there's no additional up-front cost.  It's very easy to perform informal testing even without writing a test plan---just run the software and try thinking of base cases and edge cases on the fly.
3. _It's easy to set up._  If you can get the software to compile and run---which hopefully you will be able to do anyway, since software which can't run is usually not appreciated much by users---then you have everything that you need to do some basic manual testing.  Creating test harnesses, setting up test drivers, and all of the other related work for running automated tests can be bypassed.
4. _There is no additional software to learn, purchase, and/or write._ Although there are free options available for testing tools, keep in mind that purchase price is not the only price you pay when using a software product for development.  There is time to be spent on learning how the tool works, the syntax of any scripting language it uses, and working around the inevitable bugs that it contains.  Researching the most appropriate testing tool to use, having test engineers learn to use it, and writing (and debugging) the scripts for it can all reduce the amount of time available for actually running the tests and thinking about test design.
5. _It's extremely flexible._  If a user interface changes, it's relatively straightforward to modify the test plan.  If you are doing exploratory testing or other testing outside of a test plan, as long as the tester knows about the change, they can modify the steps taken.  Even if the tester does not know about the interface changes, it may be possible for a human being to figure out the differences just by using the software.  This is not possible in automated testing; if an interface changes, then any automated tests exercising that interface will usually fail unless the testing code has been changed to expect the new interface.  This may be a benefit, though; automated tests are far more rigid, which means that they may be better at catching unanticipated modifications.  Humans may not even notice certain changes and just "go with the flow."
6. _You are more likely to test things that users care about._ Manual testing can only be done on the software running as a user would run it; it's a form of black-box testing.  By doing this, the tester is seeing the software the way a user sees it, and will tend to use the software in similar ways.  Not only does this mean that testers will gain an understanding of how the software is used, and gain domain knowledge in the area, it also means that the focus will be on aspects of the software that users care about.  Users do not care about specific values returned from specific functions buried deep within the code; they care if the final results are correct.  In manual testing, your focus will almost automatically be on the functionality of the software that the users care about the most, because the testers will also be users.
7. _Humans can catch issues that automated testing does not._ Automated tests will find failures for anything that they have been written to check.  However, if they are not written to check some aspect of the software, even if it would be easily noticed by the human eye, they will not note it as a failure.  As an example, imagine a simple word-counting program.  Automated tests check that it gives the correct answer in response to all sorts of different input.  However, it also sends some additional escape characters to the terminal that changes the screen's background color to purple.  This would be immediately recognizable and filed as a defect by a human tester, but unless there are automated tests checking specifically for background color of future output, it will go unnoticed.

### Drawbacks of Manual Testing

1. _It's boring._ Have you ever spent an entire day pressing a button, then writing down the result, then pressing a button, then writing down a result, _ad nauseam_?  It's a great way to burn out and alienate employees.  If that's not your goal, however, you want to keep the amount of boring tasks down to a minimum.
2. _It's often not repeatable._ If a tester does something slightly out of the ordinary and finds a defect, he or she may not be able to reproduce the exact steps that caused the defect to show itself.  This is to some extent ameliorated by well-defined and well-specified test plans, but even if you have extremely granular instructions, you may find it difficult to reproduce the _exact_ steps taken to get to a certain point.  For example, imagine a test case for a web browser test plan.  One of the execution steps is to "open a new tab".  However, there are multiple ways to do this; does the tester select the New Tab option from the menu, or use a keyboard shortcut, or right-click on a link and open it in a new tab?  Perhaps the defect only occurs under one of these situations.  With automated tests, you will be able to re-run the test very precisely, using the same steps each time.
3. _Some tasks are difficult or impossible to test manually._ Let us assume that you are testing the performance of a system where one of the requirements states that there should be less than a 50 millisecond delay between receiving a request and returning a response.  Since human reaction time is more than four times the maximum delay, even if the display is instantaneous, it would be impossible to check manually.  There may be other aspects of the program which are invisible to the user, but only directly testable via programs or other tools, such as the number of threads running or the value of a variable.
4. _Human error is a possibility._ Every time you have a person do something, there is a chance that that person will make a mistake.  In the case of executing a test case, a human being could read the instructions incorrectly, misunderstand them, write the test status down in the wrong place, or otherwise run the test incorrectly.  The longer that you have somebody performing manual testing, the more likely that an error like this will occur.  Other organizations have figured this out long ago---truck drivers and airplane pilots, for example, have limitations on how long they can operate their vehicles without taking a break.  While an automated test could theoretically perform different execution steps than the ones it is programmed to do, the chances of it doing so are extremely remote.  Computers are very good at doing exactly what you tell them to do, and doing it over and over again.
5. _It is extremely time- and resource-intensive._ Testing personnel manually pressing keys, clicking buttons, or doing anything else with the software limits them to the speed that an ordinary user would do those things.  Even that is a theoretical maximum, as testers must also read and follow the test plan, double-check that they performed the steps correctly, mark down statuses, and perform overhead work when they manually test. Running manual tests can be multiple orders of magnitude slower than well-written automated tests, even performing the same actions.  Running 1,000 test cases manually may take a week for a team of testers to do; it may take less than 10 minutes on a desktop computer.  This means that either much of testers' time will be spent on monotonous tasks, or others will have to be hired to run the tests.
6. _It limits you to black-box and grey-box testing._ It is essentially impossible to do white-box testing manually for programs written in many popular programming languages.  You will not be able to test individual methods or functions, but only in how they interact with the rest of the system.  Depending on how complex the program is, this may make it much more difficult to find defects, since you will not be able to operate on nearly as granular a level.

## Benefits and Drawbacks of Automated Testing

### Benefits of Automated Testing

1. _There is no chance of human error during test execution._ If there is one thing at which computers are great, it's performing the exact same operations over and over again.  Write a program to draw a circle, the circle drawn the first time the program is executed will look exactly like the one thousandth circle.  This is not the case with humans---some circles will be shakier, some will be larger than others, some may look close to perfect and some will be marred with imperfections.  Similarly, an automated test will perform the exact same set of execution steps each time---it won't accidentally perform the tests in the wrong order, it won't click on the wrong button, it won't accidentally mark down the wrong status.
2. _Test execution is extremely fast._ Computers can execute and check results much faster than any human being can.  This not only allows tests to be run more quickly, but also allows for more possible test runs, and thus more tests.
3. _It is easy to execute, once the system is set up._ Setting up a system to run a manual test can be a laborious process.  Software must be installed, test tracking software must be set up, appropriate data may need to be loaded into the database.  With most automated testing solutions, running a test suite is as simple as clicking a button on the IDE or running a command from the command line.  This not only helps minimize the amount of busy work done by testers, it allows faster iteration time between development and testing of code.
4. _It is easily repeatable._ As mentioned earlier, relying on automated tests minimizes the chance of human error.  Even without "errors", though, having tests be almost perfectly repeatable reduces the incidence of non-deterministic errors (that is, errors that only occur sometimes when running the test, not every time that the test is run).  By performing exactly the same steps in exactly the same order, the chance that a test will fail "randomly" is lessened, although not completely eliminated.  As a side note, these "random" failures almost certainly have a root cause, it's just that you as a tester have not discovered it yet.
5. _It is simple to analyze the process._ Finding patterns in test failures is much easier to do when all of the test case statuses are stored and can be re-run numerous times.  If past test runs are stored, it's even possible to determine which test cases and kinds of test cases are finding defects, and which are just always passing, because the aspects of the system they are testing have not changed much or just contain very few defects.
6. _It is less resource-intensive._ Running a thousand tests on your local computer may make it unusable for ten minutes, but that certainly is preferable to having the entire test team work on it for a week.  Computing power is getting cheaper and cheaper every year; the same cannot be said of engineers' time.
7. _It is ideal for testing some aspects of the system which manual testing is bad at testing._ Parts of the system which are not directly user-facing, such as internal variables or data written to a database, at a minimum require extra work to check when manually testing.  They may even be impossible.
8. _It scales very well._ Adding automated tests often results in a sublinear increase in time, since much of the time for automated tests often consists of setup time.  That is, adding five test cases to an existing plan consisting of five cases will most likely result in an execution time that is much less than twice the original test plan.  Adding additional manual test cases can often result in a superlinear increase in time in run execution, since humans running through the test cases manually will not be able to maintain a consistent speed, and will tend to slow down the longer that they spend running tests themselves.  More and more time will be needed to double-check results as their mental energies are exhausted.

### Drawbacks of Automated Testing

1. _It requires extra setup time up-front._ Once you understand the basic concepts of writing a test plan (which hopefully readers of this chapter have already learned in the preceding chapters), it's relatively straightforward to start writing a test plan and determining test cases for a piece of software.  However, if you are writing automated tests, not only will you have to ensure that the code that is written is testable, you will also have to set up testing libraries and a testing framework, as well as potentially learn new syntax, terminology, and paradigms.  Even if it's a framework that you have used before, there will be some time spent setting it up for the specific system under test.
2. _It may not be able to catch some user-facing defects._ Even if you know to look for them, the testing framework and libraries that you are using may not be able to check for certain defects or kinds of defects.  For example, suppose you have a custom-built framework for the graphical user interface of your application.  This framework can tell you the content of a window and if it is visible, but not its location.  If the system does not display the window in the correct location, you have no way of knowing with an automated system.  This can be somewhat ameliorated by using industry-standard frameworks and display systems, but sometimes one or both of these is not a possibility.
3. _It requires learning how to write automated tests, as well as additional tools and frameworks._ Writing automated tests is a skill that is very different from manual tests.  Although the logic and theory are similar, writing automated tests requires even more emphasis on being exact as well as ensuring that interactions with the system itself are spelled out in detail.
4. _It requires more skilled staff._ Although manual testing can be done without extensive technical knowledge, automated tests require at least a basic understanding of computer programming or scripting.  Testing staff will have to either already be familiar with the testing framework used for the system under test, or time and resources must be spent for them to learn it.  During the time that they spend learning the system, they will not be very effective in producing tests or finding defects with them.
5. _Automated tests only test what they are looking for._ While humans running tests may easily notice that there is a problem with some part of the program even if they are not specifically looking for it, computers will do no such thing.  If you have not written a test to check that entering `5 + 5` on the calculator should equal `10`, then when it equals 11, no error will be reported.
6. _Tautological tests and other bad tests may creep in._ Very large test suites can often accumulate cruft, since they may not be looked at by human eyes for long periods of time.  As long as the tests pass, they stay in the code; meanwhile, small modifications and fixes may creep into the codebase.  Over time, this could result in some __tautological test cases__ (that is, tests that will always pass because they are checking statements that are always true, such as `1 == 1`).  Or, some tests may become no longer necessary (e.g., checking parts of the program that are no longer used or are inaccessible to users).  Without explicit work to ensure that the tests remain up to date, you may find that your computer is spending more time testing than is strictly necessary.

## The Real World

Of the two options, manual and automated testing, which is better?  "Better" is a loaded term, of course; numerous other factors will come into play when making a decision.  One of the interesting things about software testing is that automated and manual tests do not have much overlap; things that manual testing is good at doing, automated testing tends not to be good at doing, and vice-versa.  There are certainly a few things that neither traditional automated testing or manual testing are good at catching, such as security testing or probing for many edge cases.  We'll discuss some variations in testing in later chapters that can fill in the weaknesses of the traditional kinds of testing we are discussing now.

The decision on whether or not to use manual or automated testing for a particular system, subsystem, or requirement will be influenced by a variety of factors:

1. _How important_ are the tests?
2. _How much of an impact_ does user interface or other "intangible" aspects have on the finished product?
3. _How often_ will the tests be run?
4. _How experienced_ is the test team?
5. _What is the schedule_ for testing?
6. _How difficult_ is it to automate the tests?

In general, the vast majority of testing, from a strict "number of tests run" perspective, will be automated tests of one sort or another.  Running a well-designed unit test can take as little as a few microseconds of computer time; even the simplest manual test will require much more time than that for even very simple test cases.  Automated tests are much easier to run more often and more quickly.  All else being equal, it is better to have more tests that are faster and more frequent than it is to have fewer tests that are slower and less frequent.

When should you, as a tester, automate tests?  If a test can be automated in a reasonable amount of time, you should almost always automate it.  Doing so streamlines your testing and development process, guards against human error in future test runs, and makes your life less boring.  However, there are occasional issues which prevent you from writing automated tests; parts of the system may not have a testing framework, a time crunch absolutely prevents you, or you just can't get the automated tools to work under certain conditions you would like to test.  In these cases, it may make sense to simply perform a manual test and come back later to automate it.  A bit of warning, though---in the majority of cases, "later" never comes, and you're stuck performing a rote and repetitive task for the foreseeable future.

In the "real world" of software development, virtually all organizations that I'm familiar with use a mixture of manual and automated tests for their applications, with the emphasis almost always falling more heavily on automated testing.  Overall, automated testing provides many benefits for modern software development, especially being able to quickly run tests after changes are made to ensure that no regression defects have occurred.  Although there is certainly an up-front cost to adding an automated testing framework, for non-trivial projects, the benefits you get from allowing the computer to do the testing work for you will quickly outweigh those drawbacks.  On the other hand, releasing software relying solely on the automated tests---without ever checking how the software actually runs for a user---is done only by those organizations whose software is very far removed from user experience, who have an extremely high level of confidence in their automated tests, and/or which are especially foolhardy.

